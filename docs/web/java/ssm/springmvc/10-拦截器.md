# 拦截器

## 拦截器的配置
SpringMVC 中的拦截器用于拦截控制器方法的执行

SpringMVC 中的拦截器需要实现`HandlerInterceptor`

SpringMVC 的拦截器必须在 SpringMVC 的配置文件中进行配置：


```xml

<bean class="com.atguigu.interceptor.FirstInterceptor"></bean>
<ref bean="firstInterceptor"></ref>
<!-- 以上两种配置方式都是对 DispatcherServlet 所处理的所有的请求进行拦截 -->

<mvc:interceptor>
    <mvc:mapping path="/**"/>
    <mvc:exclude-mapping path="/testRequestEntity"/>
    <ref bean="firstInterceptor"></ref>
</mvc:interceptor>

<!--
    以上配置方式可以通过 ref 或 bean 标签设置拦截器，通过 mvc:mapping 设置需要拦截的请求，通过 mvc:exclude-mapping 设置需要排除的请求，即不需要拦截的请求
-->
```

## 拦截器的三个抽象方法

SpringMVC 中的拦截器有三个抽象方法：

`preHandle`：控制器方法执行之前执行 preHandle()，其 boolean 类型的返回值表示是否拦截或放行，返回 true 为放行，即调用控制器方法；返回 false 表示拦截，即不调用控制器方法

`postHandle`：控制器方法执行之后执行 postHandle()

`afterComplation`：处理完视图和模型数据，渲染视图完毕之后执行 afterComplation()

## 多个拦截器的执行顺序

- 若每个拦截器的`preHandle()`都返回`true`

此时多个拦截器的执行顺序和拦截器在 SpringMVC 的配置文件的配置顺序有关：

`preHandle()`会按照配置的顺序执行，而`postHandle()`和`afterComplation()`会按照配置的反序执行

- 若某个拦截器的`preHandle()`返回了 false

preHandle()返回 false 和它之前的拦截器的 preHandle()都会执行，postHandle()都不执行，返回 false 的拦截器之前的拦截器的 afterComplation()会执行


